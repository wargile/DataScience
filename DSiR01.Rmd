---
title: "DSiR01"
author: "Robert A. Stevens"
date: "March 8, 2016"
output: html_document
---

*Data Science in R: A Case Studies Approach to Computational Reasoning and Problem Solving*

by Deborah Nolan and Duncan Temple Lang

http://www.rdatasciencecases.org

# Chapter 1. Predicting Location via Indoor Positioning Systems 

by Deborah Nolan and Duncan Temple Lang

## 1.1 Introduction

### 1.1.1 Computational Topics

## 1.2 The Raw Data

```{r comment=NA}
options(digits = 2)
setwd("~/GitHub/DataScience")
#txt = readLines("Data/offline.final.trace.txt")
txt <- readLines("offline.final.trace.txt")
sum(substr(txt, 1, 1) == "#")
length(txt)
```

### 1.2.1 Processing the Raw Data

```{r comment=NA}
strsplit(txt[4], ";")[[1]]
tokens <- strsplit(txt[4], "[;=,]")[[1]]
tokens[1:10]
tokens[c(2, 4, 6:8, 10)]
tokens[-(1:10)]
tmp <- matrix(tokens[-(1:10)], ncol = 4, byrow = TRUE)
mat <- cbind(matrix(tokens[c(2, 4, 6:8, 10)], 
                    nrow = nrow(tmp),
                    ncol = 6, 
                    byrow = TRUE), 
             tmp)
dim(mat)
processLine <- function(x) {
  tokens <- strsplit(x, "[;=,]")[[1]]
  tmp <- matrix(tokens[-(1:10)], ncol = 4, byrow = TRUE)
  cbind(matrix(tokens[c(2, 4, 6:8, 10)], 
               nrow = nrow(tmp),
               ncol = 6, 
               byrow = TRUE), 
        tmp)
}
tmp <- lapply(txt[4:20], processLine)
sapply(tmp, nrow)
offline <- as.data.frame(do.call("rbind", tmp))
dim(offline)
lines <- txt[ substr(txt, 1, 1) != "#" ]
tmp <- lapply(lines, processLine)
processLine <- function(x) {
  tokens <- strsplit(x, "[;=,]")[[1]]
  if (length(tokens) == 10) 
    return(NULL)
  tmp <- matrix(tokens[ - (1:10) ], , 4, byrow = TRUE)
  cbind(matrix(tokens[c(2, 4, 6:8, 10)], 
               nrow(tmp), 
               6, 
               byrow = TRUE), 
        tmp)
}
options(error = recover, warn = 1)
tmp <- lapply(lines, processLine)
offline <- as.data.frame(do.call("rbind", tmp), stringsAsFactors = FALSE)
dim(offline)
```

## 1.3 Cleaning the Data and Building a Representation for Analysis

```{r comment=NA}
names(offline) <- c("time", "scanMac", "posX", "posY", "posZ", 
                    "orientation", "mac", "signal", "channel", "type")
numVars <- c("time", "posX", "posY", "posZ", "orientation", "signal")
offline[numVars] <-  lapply(offline[numVars ], as.numeric)
offline <- offline[offline$type == "3", ]
offline <- offline[ , "type" != names(offline) ]
dim(offline)
offline$rawTime <- offline$time
offline$time <- offline$time/1000
class(offline$time) <- c("POSIXt", "POSIXct")
unlist(lapply(offline, class))
summary(offline[, numVars])
summary(sapply(offline[ , c("mac", "channel", "scanMac")], as.factor))
offline <- offline[ , !(names(offline) %in% c("scanMac", "posZ"))]
```

### 1.3.1 Exploring Orientation

```{r comment=NA}
length(unique(offline$orientation))
plot(ecdf(offline$orientation))
#pdf(file = "Geo_ECDFOrientation.pdf", width = 10, height = 7)
oldPar <- par(mar = c(4, 4, 1, 1))
plot(ecdf(offline$orientation), pch = 19, cex = 0.3,
     xlim = c(-5, 365), axes = FALSE,
     xlab = "orientation", ylab = "Empirical CDF", main = "")
box()
axis(2)
axis(side = 1, at = seq(0, 360, by = 45))
par(oldPar)
#dev.off()
```

**Figure 1.2. Emperical CDF of Orientation for the Hand-Held Device.  This emperical distribution function of orientation shows that there are 8 basic orientations that are 45 degrees apart.  We see from the stps in the function that these orientations are not exactly 45, 90, 135, etc. Also, the 0 orientation is split into the two groups, one near 0 and the other near 360.**

```{r comment=NA}
#pdf(file = "Geo_DensityOrientation.pdf", width = 10, height = 5)
oldPar = par(mar = c(4, 4, 1, 1))
plot(density(offline$orientation, bw = 2),  xlab = "orientation", main = "")
par(oldPar)
#dev.off()

roundOrientation <- function(angles) {
  refs <- seq(0, by = 45, length  = 9)
  q <- sapply(angles, function(o) which.min(abs(o - refs)))
  c(refs[1:8], 0)[q]
}
offline$angle <- roundOrientation(offline$orientation)
```

```{r comment=NA}

```

```{r comment=NA}

```

Figure 1.3: Boxplots of Orientation for the Hand-Held Device. These boxplots of the original orientation against the rounded value confirm that hte values have mapped correctly to 0, 45, 90, 135, etc. The "outliers" at the top left corner of the plot are the values near 360 that have been mapped to 0.

### 1.3.2 Exploring MAC Addresses

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

Figure 1.4: Screenshot of the coffer.com Mac Address Lookup Form. The coffer.com Web site offers lookup services to find the MAC address for a vendor and vice versa.

```{r comment=NA}

```

```{r comment=NA}

```


### 1.3.3 Exploring the Position of the Hand-Held Device

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

Figure 1.5: Counts of signals detected at each position. Plotted at each location in the building is the total number of signals detected from all access points for the offline data. Ideally for each location, 110 signals were measured at 8 angles for each of 6 access points, for a total of 5280 recordings. These data include a seventh Mac address and not all signals were detected, so there are about 5500 recording at each loction.

### 1.3.4 Creating a Function to Prepare the Data

```{r comment=NA}

```

```{r comment=NA}

```

```{r comment=NA}

```

## 1.4 Signal Strength Analysis

```{r comment=NA}

```

### 1.4.1 Distribution of Signal Strength

```{r comment=NA}

```

### 1.4.2 The Relationship between Signal and Distance

```{r comment=NA}

```

## 1.5 Nearest neighbor Methods to Predict Location

```{r comment=NA}

```

### 1.5.1 Preparing the Test Data

```{r comment=NA}

```

### 1.5.2 Choice of Orientation

```{r comment=NA}

```

### 1.5.3 Finding the Nearest Neighbors

```{r comment=NA}

```

### 1.5.4 Cross-Validation and Choice of k

```{r comment=NA}

```

## 1.6 Exercises
